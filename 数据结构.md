# 一、绪论

## 1.数据结构和算法

## 2.时空复杂度



## 3.ADT抽象数据类型

抽象数据类型，可以看作一些数据对象以及附加在对象上的操作的集合，如栈ADT可以描述为：插入和删除只能在一端进行的线性表；队列则是插入在一端进行，删除在另一端进行的线性表。ADT描述功能但不关心具体实现。

ADT还包含了数据关系集，如线性表的一对一、树的一对多、图的多对多关系。

# 二、线性表

## 1.线性表的定义和基本操作

定义：具有相同数据类型的n个数据元素的有序序列，n为表长，n=0时为空表，a~1~是唯一表头元素，a~n~是唯一表尾元素，除表头表尾外，每个元素有且只有一个直接前驱和后继。

特点：个数有限、逻辑上有序、数据元素、类型相同、抽象性。

线性表是一种逻辑结构，顺序表和链表则是存储结构。

基本操作有：

~~~C++
InitList(&L){}
Length(L){}
LocateElem(L,e){}
GetElem(L,i){}
Insert(&L,i,e){}
Delete(&L,i,&e){}
PrintList(L){}
Empty(L){}
DestroyList(L){}
~~~



### 2. 线性表的实现：顺序表

线性表的顺序存储称为顺序表，是一组地址连续的存储单元依次存储线性表中的数据元素，使逻辑上相邻的两个元素在物理位置上也相邻，逻辑顺序和物理顺序相同。

一维数组可以是静态分配也可以是动态分配的，静态分配中空间满可能造成溢出错误，动态分配在空间满后可以开辟一块更大的空间替换。

~~~C++
#define MaxSize 50
typedef struct{
    ElemType data[MaxSize];
    int length;
}SqList;	//静态顺序表

#define InitSize 100
typedef struct{
    ElemType *data;
    int MaxSize,length;
}SeqList;	//动态分配
L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize);	//C语言初始分配
L.data=new ElemType[InitSize];	//C++初始分配
~~~

#### 基本实现

对于插入、删除、查找，最好时间复杂度为对表头处理，O(1)；最坏为对表尾处理，O(n)；平均为n/2、(n-1)/2、(n+1)/2，也即O(n)。

~~~C++
int InitList(&L){
    
}
int Length(SeqList &L){return L.length;}
ElemType GetElem(SeqList &L,int i){return L.data[i];}
int PrintList(SeqList &L){for(int i=0;i<L.length;i++)printf("Elemnt in %d position is: %d\n",i,L.data[i]);}
int Empty(SeqList &L){
    if(L.length<=0)
        return 1;
    else{
        delete L.data[];
        L.length=0;
        return 0;
    }
}
int DestroyList(SeqList &L){
    if()
        
}

bool Insert(SeqList&L,int i,ElemType e){	//指定位置插入指定值
    if(i<1||i>L.length+1)
        return false;
    if(L.length>=MaxSize)
        return false;
    for(int j=L.length;j>=i;j--)
        L.data[j]=L.data[j-1];
    L.data[i-1]=e;
    L.length++;
    return true;
}	

bool Delete(SeqList &L, int i, ElemType &e){
    if(i<1||i>L.length+1)
        return false;
    e=L.data[i-1];
    for(int j=i;j<L,length;j++)
        L.data[j-1]=L.data[j];
    L.length--;
    return true;
}

int LocateElem(SeqList &L ,ElemType e){
    int i=0;
    while(i<L.length && L.data[i]!=e)
        i++;
    return i==L.length?0:i+1;
}


~~~



### 3. 线性表的链表实现

插入删除不需要移动元素，只需要修改指针，但失去了随机存取的优先，需要通过遍历访问元素。基本实现形式如下：

#### 1. 单链表

单链表是最简单的线性表链式存储，每个结点有数据域和指针域，指针域指向后继结点，可以解决顺序表需要大量连续存储空间的缺点，但是由于附加指针域，浪费存储空间降低存储密度，由于非随机存取，需要通过遍历查找结点。通常使用头指针标识一个单链表，如单链表L；头指针为NULL标识一个空表，一般也在第一个结点之前附加一个结点，称为头结点，头结点可以不存放任何信息，或记录表长信息，不管是否存在头结点，单链表的头指针都指向第一个链表元素。头指针的优点有：:one: 第一个数据结点的位置存放在头结点的指针域，链表在第一个位置上的操作和其他位置一致，无需特殊操作，:two: 无论链表是否为空，头指针都指向头结点的非空指针，使空表和非空表的操作也得到了统一。



~~~C++
typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode,*LinkList;

LinkList ListHeadInsert(LinkList &L){	//头插法建立
    LNode *s;int x;
    L=new LNode;
    L->next=NULL;
    scanf("%d",&x);
    while(x!=9999){
        s=new LNode;
        s->data=x;
        s->next=L->next;
        L->newt=s;
        scanf("%d",&x);
    }
    return L;
}

LinkList ListTailInsert(LinkList &L){
    int x;
    L=new LNode;
    LNode *s,*r=L;
    scanf("%d",&x);
    while(x!=9999){
        s=new LNode;
        s->data=x;
        r->next=s;
        r=s;
        scanf("%d",&x);
    }
    r->next=NULL;
    return L;
}

LNode *GetElem(LinkList L,int i){
    int j=1;
    LNode *p=L->next;
    if(i==0)
        return L;
    if(i<1)
        return NULL;
    while(p&&j<i){
        p=p->next;
        j++;
    }
    return p;
}

LNode *LocateElem(LinkList L,ElemType e){
    Lnode *p=L->next;
    while(p!=NULL && p->data!=e)
        p=p->next;
    return p;
}

int Insert(LinkList &L,int i,Elemtype e){	//在第i个结点p前插入结点s
    if(i<0 || i>L->data)	//默认头结点的data域存放链表长度；
        return 0;
    Lnode *s=new LNode,*p=GetElem(L,i-1);
    s->next=p->next;		//s结点实际上在p结点后，但交换数据域后相当于在p结点前
    p->next=s;
    s->data=p->data;
    p->data=e;
    L->data++;
    return 0;
}

int Delete(LinkList &L,int i){
    LNode *p=GetElem(L,i-1);
    p->data=p->next->data;
    p->next=p->next->next;
    delete p->next;
    L->data--;
    return 0;
}

int Length(LinkList &L){
    int i=0;
    LNode *p=L;
    while(p->Next!=NULL)
        i++;
    L->data=i;
    return i;
}

~~~



#### 2. 双链表

为了克服单链表查找前驱结点需要O(n)的缺点，指针域增加prior指针指向前驱。

~~~C++
typedef struct DNode{
    ElemType data;
    struct DNode *prior,*next;
}DNode,*DLinkList;
~~~



#### 3. 循环单链表

将单链表的尾指针的next设为头指针，使链表在逻辑上成为一个环，此时遍历条件从p->next!=NULL变为p->next!=L；也可以不保存头指针，而用尾指针r标识链表，使用r可以直接对表尾操作，使用r->next可以直接对表头操作，两者时间复杂度都是O(1)。



#### 4. 循环双链表

将双链表的表首prior指向表尾，表尾的next指向表头，逻辑上形成双环形。判空条件为头结点L的双指针域都指向L。

#### 5. 静态链表

利用数组来描述线性表，节点有数据域和指针域，指针是相对位置，即数组中的下标，也称游标。静态链表需要预先分配一块空间。

一般使用在不支持指针的高级语言中。一般以next=-1作为链表结束标志。



| 比较           | 顺序表                                                       | 链表                                                         |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 存取方式       | 可以随机访问，仅需1次                                        | 只能从表头顺序存取，需要依次访问i次                          |
| 逻辑与物理结构 | 逻辑和物理结构都相邻                                         | 逻辑结构相邻，物理结构不一定相邻，通过指针链接               |
| 增删改查       | 插入删除需要移动大量元素，复杂度O(n)，但对于查找，在有序时可以使用折半，则复杂度为O(log~2~n)。随机访问所以访问指定元素复杂度O(1)。 | 插入删除可以直接修改指针，但是寻找插入位置需要遍历，所以插入删除操作的复杂度仍为O(n)，但一般遍历比移动速度块，所以性能一般更优。查找和访问均需遍历，所以复杂度为O(n)。 |
| 空间分配       | 静态存储分配下，装满就会溢出，但是预分配过大导致浪费；动态分配可以扩充空间，但内存中必须有足够大的连续空闲空间，且移动也需要大量时间。但是没有指针域数据存储密度高。 | 空间分配十分灵活，但是因为有指针域，存储密度低。             |
| 基于存储       | 可以预估线性表长度和规模时，可以使用                         | 链表不用实现估计规模                                         |
| 基于运算       | 顺序表中按序号访问元素复杂度为O(1)，在按序号访问密集时，性能较好。 | 链表按序号访问、增删改查的复杂度为O(n)，在数据量大且较多删改时性能较好。 |
| 基于环境       | 实现简单                                                     | 链表的操作基于指针，不支持指针的高级语言无法使用。           |



### 4.线性表相关试题









# 三、栈和队列

线性表操作受限时，就退化成了栈和队列，对线性表进行推广（如维度、物理位置等）后就成为数组（多维数组）

### 1.栈FILO

### 2.队列FIFO







# 四、数组串（string）

## 1.一维数组

数组是由n个相同类型元素构成的有限序列，每个数据元素称为一个数组元素，每个元素的序号i称为元素下表，下标取值范围称为数组的维界。数组一旦被定义，其大小、存储位置、维数、维界不可再改变，除了初始化和销毁，数组只有存取和修改的操作，没有增删。

## 2.串

### 定义

串是字符组成的有限序列，字符个数即长度，零长度即空串

### 存储

（1）定长顺序存储：以'\0'为结束标记，则求长度需要扫描全串时间复杂度O(n)，所以加一个int length

```c++
#define MAXN 255
typedef struct{
	char str[MAXN+1];
	int length;
}
```

(2)变长分配存储：（动态分配存储

```c++
typedef struct{
	char * ch;
	int length;
}
```

### 基本操作

#### (1)赋值

不能直接'='因为本质上是一个数组，必须逐一

```c++
int strassign(Str& str,char* ch){
	if(str.ch)
        free(str.ch)
	int len=0;
    char* c=ch;
    while(*c){//求长度
        ++len;++c;
    }
    if(len==0){
        str.ch=NULL;
        str.length=0;
        return 1;
    }
    else{
        str.ch=(char*)malloc(sizeof(char)*(len+1));//多一个空间存结束符
        if(str.ch==NULL)
            return 0;
        else{
            c=ch;
            for(int i=0;i<=len;++i,++c)
                str.ch[i]=*c;//复制到结束符为止
            str.length=len;
            return 1;
        }
    }
}
```

#### (2)取长度：return str.length；

#### (3)比较：字典序

```c++
int strcmp(Str s1,Str s2){
    for(int i=0;i<s1.length && i<s2.length;++i)
        if(s1.ch[i]!=s2.ch[i])
            return s1.ch[i]-s2.ch[i];
    return s1.length-s2.length;
}//返回值正，s1大
```

#### (4)连接

```c++
int concat(Str& str,Str S1,Str s2){
    if(str.ch){
        free(str.ch);
        str.ch=NULL;
    }
    str.length=s1.length+s2.length;
    str.ch=(char*)malloc(sizeof(char)*(str.length+1));
    if(str.ch==NULL)
        return 0;
    for(int i=0;i<s1.length;++i)
        str.ch[i]=s1.ch[i];
    for(int i=0;i<=s2.length;++i)//复制到结束符为止
        str.ch[i]=s2.ch[i];
    return 1;
}
```

#### (5)子串：pos开始，长度为len，由substr传回

```c++
int strsub(Str& substr,Str str,int pos,int len){
    if(pos<0||pos>=str.length||len<0||len>str.length-pos)
        return 0;
    if(substr.ch){
        free(substr.ch);
        substr.ch=NULL;
    }
    if(len==0){
        substr.ch=NULL;
        substr.length=0;
        return 1;
    }
    else{
        substr.ch=(char*)malloc(sizeof(char)*(len+1));
        int j=0;
        for(int i=pos;i<pos+len;i++)
            substr.ch[j++]=str.ch[i];
        substr.ch[j]='\0';
        substr.length=len;
        return 1;
    }
}
```

#### (6)清空：

```c++
int strclear(Str& str){
    if(str.ch){
        free(str.ch);
        str.ch=NULL;
    }
    str.length=0;
    return 1;
}
```

### 模式匹配

#### (1)简单模式匹配

```c++
int index(Str str,Str s){
    int i=1,j=1,k=i;
    while(i<=str.length && j<=s.length){
        if(str.ch[i]==s.ch[j]){
            ++i;++j
        }
        else{
            j=1;
            i=++k;
        }
    }
    if(j>s.length)
        return k;
    else return 0;
}
```



#### (2)KMP

优点：通过模式串的移动使匹配的比较次数减少，利用next[]数组记录后移位置，用空间换时间，提高了算法执行速度。其次，因为比较指针i不需要回溯，所以对于规模较大的外存中的匹配操作可以分段进行，读入内存完成匹配后写回外存，减少I/O操作提高效率。

```c++


```





#### (3)KMP改进





## 3.矩阵（二维数组）

二维数组是元素是一维数组的一维数组。

存储分为行优先和列优先，行优先存储先算行标后算列标，存储时一行一行为单位放入线性存储单元；列优先则先算列标后算行标，存储时一列一列放入存储位置；如在A【6】【9】中，A【i】【j】对于行优先k=ix9+j+1；（默认首位是00），对于列优先是k=jx6+i+1。

二位数组也可以称为矩阵，下面给出简单的矩阵运算

~~~C++
#define m 4;
#define n 5;
int A[m][n];
void trsmat(int a[][maxSize],int b[][maxSize],int m,int n){/*转置，二维数组传参时必须指定第二维长度,下面省略了非法判断以及数组大小的控制，先设置为maxSize，通过m和n控制实际尺寸*/
    for(int i=0;i<m;i++)
        for(int j=0;j<n;j++)
            b[j][i]=a[i][j];
}

void addmat(int a[][maxSize],int b[][maxSize],int b[][maxSize],int m,int n){	/* */
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            c[i][j]=a[i][j]+b[i][j];
}

void mutmat(int c[][maxSize],int a[][maxSize],int b[][maxSize],int m,int n,int k){
    for(int i=0;i<m;i++)
        for(int j=0;j<k;j++){
            c[i][j]=0;
            for(int h=0;h<n;h++)
                c[i][j]+=a[i][h]*b[h][j];
        }
}
~~~

### 2.特殊矩阵

特殊矩阵可以通过特殊方式进行存储，主要特殊矩阵有对称、对角、三角、稀疏矩阵。

#### 1. 对称矩阵

由于主对角线上下元素对称，所以有a~j·i~=a~i·j~，可以需要(1+n)xn/2个空间存储，按照行优先展开存储。部分元素存储位置见下表

| A~0，0~ | A~1，0~ | …    | A~n-1，0~   | A~n-1，1~      | …    | A~n-1，n-1~    |
| ------- | ------- | ---- | ----------- | -------------- | ---- | -------------- |
| 0       | 1       | …    | n*（n-1）/2 | n*（n-1）/2 +1 | …    | （1+n）*n/2 -1 |



#### 2. 三角矩阵

类似于对称，对于上三角中的下三角区域，即为c，存储在最后。

| A~0，0~ | A~1，0~ | …    | A~n-1，0~   | A~n-1，1~      | …    | A~n-1，n-1~    | c           |
| ------- | ------- | ---- | ----------- | -------------- | ---- | -------------- | ----------- |
| 0       | 1       | …    | n*（n-1）/2 | n*（n-1）/2 +1 | …    | （1+n）*n/2 -1 | （1+n）*n/2 |

#### 3. 对角矩阵

爪形矩阵，存储时将元素映射到对应位置即可。

#### 4. 稀疏矩阵

   1. 数组表示（三元组、伪地址）

      ~~~C++
      typedef struct{
          int val;
          int i,j;
      }Trimat;
      Trimat trimat[maxterms+1];
      int trimat[maxterm+1][3];//也可以简便写成这种形式，但如果数据是float类型，取地址后还需要强制转换int
      
      ~~~

      结点次序按照行优先，第1个元素存值，第2、3个存i、j位置。

      伪地址类似于三元组，是按照行优先展开后存储相对位置，伪地址只需要一个单元存放地址，而三元组需要两个，对于A~i·j~，伪地址计算为k=n(i-1)+j，根据这一公式就可以完成地址映射，可以用二维数组存储较少个非零元素。

   2. 邻接表表示

      将每一行的非零元素串成一个链表，链表结点存放元素值和对应序号。

   3. 十字链表表示

      ![十字链表](http://images.cnitblog.com/blog/214741/201304/02122320-e6c9a4ebb41044f4918dd01774262b27.png)

      矩阵的每一行用一个带头结点的链表表示，

      ~~~C++
      typedef struct OLNode{	//普通结点定义
          int row,col;
          struct OLNode *right,*down;
          float val;
      }OLNode;
      typedef struct{			//头结点定义
          OLNode *rhead,*chead;
          int m,n,k;
      }CrossList;
      ~~~

      

## 4.广义表

表元素可以是原子也可以是广义表的一种线性表的扩展结构。

长度表示表最上层元素个数，深度表示最大层数，表头指第一个元素，表尾指最后一个元素。一个表结点有三个域，头指针prior、尾指针next和标记域data指向数据存储位置。

广义表的每个子表都有一个不带存储信息的头结点标记其存在。

# 五、树与二叉树



## 1.树的基本概念：

## 2. 二叉树基本概念

## 3.二叉树的遍历、线索二叉树

## 4.树和森林

## 5.二叉排序树

## 6.平衡二叉树

## 7.哈夫曼树



# 六、图

## 1. 基本概念

## 2. 存储和基本操作

## 3. 图的遍历：BFS、DFS

## 4. 最小生成树（LST）

## 5. 最短路径

## 6. 拓扑排序、AOV网

## 7. 关键路径、AOE网

# 七、查找

## 1. 基本概念

## 2. 线性结构

####   1. 顺序查找
####   2. 折半查找

####   3. 分块查找

## 3. 树形结构

###   1. 二叉排序树

###   2. 二叉平衡树

###   3. B-树和B+树

## 4. 散列表（Hash）

散列函数（Hash）函数：将查找的关键字映射成对应地址的函数，Hash(key)=Addr，地址可以是数组下标、索引、内存地址。

散列函数将多个关键字映射到同一地址称为冲突，发生冲突的不同词称为同义词，散列函数应该尽量减少冲突，也要设计处理冲突的方法。

根据关键字直接进行访问的数据结构即散列表，散列表建立了关键字和地址的直接映射关系。理想情况下对散列表的查找时间复杂度是O(1)。

#### 散列函数：

1. 直接定址法：H(key)=key或H(key)=a×key+b，计算简单，不会冲突，适合关键字分布基本连续，否则浪费空间。
2. 除数留余法：最简单常用，H(key)=key%p，关键是选好p，使每个关键字等概率映射在空间上任意地址，减少冲突可能性。
3. 数字分析法：关键字是r进制数，r个数码出现频率不相同，则可以选取数码分布均匀的若干位作为散列地址，只适用于已知关键字集，换关键字集就要重新构造新的散列函数。
4. 平方取中法：去关键字平方值的中间几位作为散列地址，地址与关键字每位都有关系，使地址分布均匀，适用于关键字每位取值不够均匀或小于散列地址所需位数。

#### 冲突处理：

1. 开放定址法：可存放新表项的空闲地址向同义词表项开放，也向非同义词的表项开放，递推式为H~i~=(H(key)+d~i~)%m，m为散列表表长，d~i~是一个增量序列，增量序列有以下4种取法。

   1. 线性探测法：d~i~=0，1，2……m-1，特点是查看下一个地址，直到找出空闲，但可能造成堆积（聚集），降低查找效率。
   2. 平方探测法（二次探测法）：d~i~=0^2^,1^2^,-1^2^,2^2^……k^2^,-k^2^时，为平方探测，k<=m/2，m必须是一个可以表示成4k+3的质数，这是一种较好的处理方法，避免堆积，但缺点是不能探测到所有单元，但至少能探测到一半。
   3. 再散列法：d~i~=Hash~2~(key)。也称双散列法，使用两个散列函数，即H~i~=(H(key)+i×Hash~2~(key))%m，i是冲突次数，初始为0，最多经过m-1次能遍历所有位置回到H~0~。
   4. 伪随机序列法：d~i~是一个伪随机序列。

   需注意：开放定址时，不能随便删除元素，删除元素可能会截断其他具有相同散列地址的元素的查找地址，删除时，可以先做标记，进行逻辑删除；但多次删除后，表面上看起来散列表很满，其实有很多空位，需要定期维护进行物理删除。

2. 拉链法（链接法、chaining）：把所有同义词存储在线性链表中，线性链表则由散列地址进行唯一标识，主要适用于经常需要插入删除的情况。

#### 查找性能分析：

查找的执行步骤如下：

> 初始化Addr=Hash(key);
>
> 检测Addr地址，若为空，返回查找失败，若相等，返回查找成功，不相等则执行下一步骤
>
> 使用给定数据冲突处理法计算下一个散列地址，将Addr置为此地址，转入步骤2。

虽然散列表建立了直接映像，但是由于冲突的存在，查找仍然是给定值和关键值比较的过程，仍需要用平均查找长度作为衡量查找效率的度量。

散列表的查找效率取决于三个因素，散列函数、处理冲突的方法、和装填因子。

装填因子，一般记为α，定义为一个表的装满程度，即${\alpha =\frac{表中记录数n}{散列表长度m}}$。

散列表的平均查找长度依赖于散列表的装填隐私α，而不依赖于m或n，记录越满，冲突可能性越大。

## 5. 分析和应用

# 八、排序

### 1. 基本概念
### 2. 插入排序
####   1. 直接插入排序

####   2. 折半插入排序
###   3. 希尔排序（Shell）
### 3. 交换排序
####   1. 冒泡排序（Bubble）
####   2. 快速排序
### 4. 选择排序
####   1. 简单选择排序
####   2. 堆排序
### 5. 基数排序
### 6. （二路）归并排序

###  7. 外部排序



### 8. 排序算法比较和应用